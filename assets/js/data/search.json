[ { "title": "Understanding the mechanishm of GetModuleHandle from Scratch via PEB from a shellcoders perspective", "url": "/posts/manually-implementing-getmodulehandle-via-peb/", "categories": "Windows Internals, Red Team", "tags": "PEB, GetModuleHandle, Windows API, Manual Mapping, Red Teaming, Malware Development", "date": "2025-04-24 14:00:00 +0530", "snippet": "Windows Internals: From TEB to GetModuleHandle - A Practical GuideIntroductionIn the world of Windows internals and offensive security, few skills are as fundamental yet as poorly understood as man...", "content": "Windows Internals: From TEB to GetModuleHandle - A Practical GuideIntroductionIn the world of Windows internals and offensive security, few skills are as fundamental yet as poorly understood as manual DLL resolution. While most developers casually call GetModuleHandle() without a second thought, understanding what happens beneath this simple API call reveals a fascinating journey through process memory structures and Windows internals.Why should you care? Because when you‚Äôre writing: Shellcode that needs to be position-independent Anti-analysis techniques for evasion Custom loaders or injection mechanisms Debugging complex process issuesThis guide will take you on a hands-on tour through: The Thread Environment Block (TEB) - your thread‚Äôs ID card The Process Environment Block (PEB) - the process‚Äôs memory diary The loader‚Äôs module lists - Windows‚Äô address book for loaded DLLs Practical implementation of your own GetModuleHandleWe‚Äôll be using: WinDbg to explore live memory structures C code that works on both x86 and x64 architectures Practical examples you can test immediatelyBy the end, you‚Äôll not only understand how Windows manages loaded modules, but you‚Äôll be able to locate them without any API calls‚Äîa crucial skill for low-level programming and security research. Fun Fact: The technique we‚Äôll explore is used by: Malware to evade API monitoring Game cheats to bypass detection Security tools to analyze processes without hooks Debuggers to understand module loading This Isn‚Äôt a Walk in the Park - It‚Äôs a Walk in the PEB!Let‚Äôs begin our journey at the very foundation the one and only Thread Environment Block!!!!Accessing the Thread Environment Block (TEB)Alright, listen up, future Windows internals wizards! Let‚Äôs take this PEB for a walk, but first :why are we even starting with the TEB? Great question!! and the anser is:The Thread Environment Block (TEB) is a fundamental Windows data structure that stores critical thread-specific information. Each thread in a process has its own TEB, which contains essential execution context including the thread‚Äôs stack boundaries (base and limit addresses), Thread-Local Storage (TLS) slots for thread-specific data, and the Structured Exception Handling (SEH) chain for error management. The TEB also holds important references like a pointer to the Process Environment Block (PEB) which we will explore in detail further below. Additionally, it maintains the thread‚Äôs LastError value, hardware breakpoint registers for debugging, and various system pointers that help manage thread execution and synchronization. This structure is crucial for low-level operations, debugging, and security analysis, as it provides direct access to a thread‚Äôs execution environment without relying on higher-level APIsAccessing the TEB Pointer programtically// Accessing the TEB pointer:x86: TEB* threadEnvBlock = (TEB*)__readfsdword(0x18); // FS:[0x18]x64: TEB* threadEnvBlock = (TEB*)__readgsqword(0x30); // GS:[0x30]Accessing TEB in Windbgdt nt!_TEB @$tebInspecting PEB Pointer Offset via TEB in windbg: 32-bitInspecting PEB Pointer Offset via TEB in windbg: 64-bitLocating the the PEB (Process Environment Block)Every process has a PEB (Process Environment Block), which is basically Windows‚Äô way of saying:‚ÄúHere‚Äôs everything you loaded, everything you‚Äôre doing, and oh yeah!! if you‚Äôre being debugged üëÄ.‚ÄùThe Process Environment Block (PEB) is a vital internal structure in Windows that stores comprehensive information about a process at runtime. It acts as a centralized repository containing critical data such as loaded modules (DLLs and EXEs), process heap pointers, command-line arguments, environment variables, and startup information.Beyond configuration data, the PEB also includes flags for debugging detection (e.g., BeingDebugged), memory protections like ASLR/DEP, and various integrity checks that help manage and secure the process. Due to its rich information, the PEB becomes an attractive target for security researchers, malware analysts, and shellcode developers, enabling tasks like stealthy debugging detection, process hollowing, in-memory module enumeration, and advanced forensics.Accessing the PEB directly allows one to enumerate loaded modules without invoking high-level Windows APIs, offering a stealthier and more low-level view of the process. Note: We will explore the PEB‚Äôs Ldr field and the internal structure PEB_LDR_DATA in more detail shortly.Architectural Differences in PEB Pointer LocationAs shown in the memory dumps above, the Process Environment Block (PEB) pointer has distinct locations across architectures: 32-bit Windows: Accessed via fs:[0x30] (TEB+0x30) 64-bit Windows: Accessed via gs:[0x60] (TEB+0x60)The shift from 0x30 to 0x60 reflects 64-bit memory addressing fundamentals: 8-byte pointers require larger offsets: Note the high/low split in 64-bit addresses, such as 0x00000087'6506b000. Structure alignment expands: This maintains performance with wider registers. Segment registers switch: From FS (32-bit) to GS (64-bit). Accessing the PEB Pointer in 32-bit and 64-bit Windows programtically// Via TEB structurePEB* procEnvBlock = threadEnvBlock-&gt;ProcessEnvironmentBlock;// Direct FS segment accessPEB* procEnvBlock = (PEB*)__readfsdword(0x30); // FS:[0x30]for 32 bit system// Direct GS segment accessPEB* procEnvBlock = (PEB*)__readgsqword(0x60); // GS:[0x60]for 64 bit systemInspecting PEB structure in windbg: 32-bitdt nt!_PEB poi(@$teb+0x30) ; for 32-bitInspecting PEB structure in windbg: 64-bitdt nt!_PEB poi(@$teb+0x60) ; for 64-bitAccessing PEB_LDR_DATA: Navigating Through PEB to Module ListsWhen a process starts, Windows internally needs a way to keep track of all the modules (DLLs and EXEs) it loads into memory. This management is handled by the _PEB_LDR_DATA structure, which is pointed to by the Ldr field inside the PEB._PEB_LDR_DATA maintains three separate doubly linked lists that organize module information in different ways depending on what aspect of loading or memory layout you care about: InLoadOrderModuleListTracks modules in the order they were loaded into the process. InMemoryOrderModuleListTracks modules based on their memory layout within the process. InInitializationOrderModuleListTracks modules in the order they were called during initialization. These lists provide a comprehensive view of the modules loaded in a process, making them essential for tasks like debugging, manual module enumeration, and low-level process analysis.And honestly, trying to differentiate between them feels a bit like this:Inspecting PEB_LDR_DATA in windbg: 32-bit:# Get PEB_LDR_DATA from TEB-&gt;PEB-&gt;Ldrdt nt!_PEB_LDR_DATA poi(poi(@$teb+0x30)+0x0c)# Alternative using LDR address directlydt nt!_PEB_LDR_DATA 0x77d04340 #(replace with actual Ldr address from your dump)Inspecting PEB_LDR_DATA in windbg: 64-bit:# Get PEB_LDR_DATA from TEB-&gt;PEB-&gt;Ldrdt nt!_PEB_LDR_DATA poi(poi(@$teb+0x60)+0x18)# Alternative using explicit LDR addressdt nt!_PEB_LDR_DATA 0x00007ffa`f410d8c0 # (replace with your Ldr address)Key Offset Differences: Ldr: Offset +0x018 in 64-bit Offset +0x00c in 32-bit Understanding Module Initialization Order in WindowsThe InInitializationOrderModuleList within the _PEB_LDR_DATA structure provides crucial insight into how Windows loads and initializes modules (DLLs) in a process. This list reveals the exact sequence in which each module‚Äôs DllMain function was executed - often different from the load order.Core Concepts1. The LIST_ENTRY StructureAt the core of Windows‚Äô internal module management lies the lightweight and efficient LIST_ENTRY structure. It provides a doubly-linked list mechanism that allows for quick insertion, removal, and traversal of elements.Rather than reinventing complex data structures for different module lists, Windows standardizes around LIST_ENTRY, ensuring consistency and speed._LIST_ENTRY structure looks like this:typedef struct _LIST_ENTRY { struct _LIST_ENTRY* Flink; // Pointer to the next entry struct _LIST_ENTRY* Blink; // Pointer to the previous entry} LIST_ENTRY, *PLIST_ENTRY; Flink points to the next entry in the list. Blink Blink points to the previous entry in the list. Key takeaway: LIST_ENTRY is purely the linking mechanism ‚Äî it doesn‚Äôt store module information itself.Access _LIST_ENTRY in Windbg : 32-bit# Method 1: Full chain from TEBdt nt!_LIST_ENTRY poi(poi(poi(@$teb+0x30)+0x0c)+0x01c) # InInitializationOrderModuleList# Method 2: Direct PEB_LDR_DATA address (replace 0x77e74340)dt nt!_LIST_ENTRY 0x77d04340+0x01c # InInitializationOrderModuleList# Walk the module list (32-bit):!list -x \"dt nt!_LDR_DATA_TABLE_ENTRY @$extret\" poi(poi(poi(@$teb+0x30)+0x0c)+0x0c)Access _LIST_ENTRY in Windbg : 64-bit# Method 1: Full chain from TEBdt nt!_LIST_ENTRY poi(poi(poi(@$teb+0x60)+0x18)+0x030) # InInitializationOrderModuleList# Method 2: Direct PEB_LDR_DATA address (replace 0x0000027e`07e34120)dt nt!_LIST_ENTRY 0x0000027e`07e34120+0x30 # InInitializationOrderModuleList# Walk the module list (64-bit):!list -x \"dt nt!_LDR_DATA_TABLE_ENTRY @$extret\" poi(poi(poi(@$teb+0x60)+0x18)+0x10)2. The _LDR_DATA_TABLE_ENTRY Structure : Wrapping LIST_ENTRY with Module DetailsWhile LIST_ENTRY handles linking, it doesn‚Äôt know anything about what it‚Äôs linking.That‚Äôs where _LDR_DATA_TABLE_ENTRY comes in ‚Äî it wraps a module‚Äôs important metadata around embedded LIST_ENTRY fields.You can think of each _LDR_DATA_TABLE_ENTRY as a very busy person walking around, carrying a giant folder stuffed with all kinds of documents: The name of the DLL (like ‚Äúkernel32.dll‚Äù) The base address in memory where the module is loaded The entry point address The size of the image Various timestamps Pointers to the next and previous module (in each list!)They‚Äôre like librarians walking through the process memory, each holding an encyclopedia about their module.Whenever you walk the InLoadOrderModuleList, you‚Äôre basically tapping each of them on the shoulder and asking,‚ÄúHey, what module are you carrying?‚ÄùWhat makes this design elegant is that each _LDR_DATA_TABLE_ENTRY is the one which embeds the three Musketeers or I should say LIST_ENTRY fields inside it : InLoadOrderLinks, InMemoryOrderLinks, and InInitializationOrderLinks mentioned above in greater detail.These embedded links allow a single module to simultaneously exist in multiple module lists, ordered by different criteria.LDR_DATA_TABLE_ENTRY structure looks like this::typedef struct _LDR_DATA_TABLE_ENTRY { LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; // ...more fields} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;_LIST_ENTRY to LDR_DATA_TABLE_ENTRY Conversion : The CONTAINING_RECORD MacroWindows provides the CONTAINING_RECORD macro to convert a LIST_ENTRY pointer back to its parent structure:#define CONTAINING_RECORD(address, type, field) \\ ((type *)((PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field)))For initialization order traversal, it is used as follows:PLDR_DATA_TABLE_ENTRY moduleEntry = CONTAINING_RECORD( listEntry, // Current LIST_ENTRY pointer LDR_DATA_TABLE_ENTRY, // Parent structure type InInitializationOrderLinks // The embedded LIST_ENTRY field);Inspecting LDR_DATA_TABLE_ENTRY in windbg: 32-bitdt ntdll!_LDR_DATA_TABLE_ENTRY (poi(poi(poi(@$teb+0x30)+0x0c)+0x1c)-0x10)Inspecting LDR_DATA_TABLE_ENTRY in windbg: 64-bitdt ntdll!_LDR_DATA_TABLE_ENTRY (poi(poi(poi(@$teb+0x60)+0x18)+0x30)-0x20)The Grand Finale: The full code to manually implement GetModuleHandle programtically:#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt; // for _tscanftypedef struct _UNICODE_STRING {\tUSHORT Length;\tUSHORT MaximumLength;\tPWSTR Buffer;} UNICODE_STRING, * PUNICODE_STRING;typedef struct _PEB_LDR_DATA {\tULONG Length;\tBOOLEAN Initialized;\tHANDLE SsHandle;\tLIST_ENTRY InLoadOrderModuleList;\tLIST_ENTRY InMemoryOrderModuleList;\tLIST_ENTRY InInitializationOrderModuleList;} PEB_LDR_DATA, * PPEB_LDR_DATA;typedef struct _LDR_DATA_TABLE_ENTRY {\tLIST_ENTRY InLoadOrderLinks;\tLIST_ENTRY InMemoryOrderLinks;\tLIST_ENTRY InInitializationOrderLinks;\tPVOID DllBase;\tPVOID EntryPoint;\tULONG SizeOfImage;\tUNICODE_STRING FullDllName;\tUNICODE_STRING BaseDllName;\t// (other fields omitted)} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;typedef struct _PEB {\tBYTE Reserved1[2];\tBYTE BeingDebugged;\tBYTE Reserved2[1];\tPVOID Reserved3[2];\tPPEB_LDR_DATA Ldr;\t// (other fields omitted)} PEB, * PPEB;//stolen from https://gist.github.com/okumura/7173625// Get PEB pointerLPVOID GetPEB() {#if defined(_WIN64)\treturn (LPVOID)__readgsqword(0x60); // GS:[0x60] for x64#else\treturn (LPVOID)__readfsdword(0x30); // FS:[0x30] for x86#endif}// Case-insensitive wide string comparisonint _wcsicmp_impl(LPCWSTR str1, LPCWSTR str2) {\tWCHAR c1, c2;\tdo {\t\tc1 = *str1++;\t\tc2 = *str2++;\t\tc1 = (c1 &gt;= 'A' &amp;&amp; c1 &lt;= 'Z') ? c1 + 32 : c1;\t\tc2 = (c2 &gt;= 'A' &amp;&amp; c2 &lt;= 'Z') ? c2 + 32 : c2;\t} while (c1 &amp;&amp; c1 == c2);\treturn c1 - c2;}// Find module base address by namePVOID GetModuleBase(LPCWSTR moduleName) {\tPPEB peb = (PPEB)GetPEB();\tif (!peb || !peb-&gt;Ldr) {\t\treturn NULL;\t}\tPLIST_ENTRY head = &amp;peb-&gt;Ldr-&gt;InLoadOrderModuleList;\tPLIST_ENTRY current = head-&gt;Flink;\twhile (current != head) {\t\tPLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(\t\t\tcurrent,\t\t\tLDR_DATA_TABLE_ENTRY,\t\t\tInLoadOrderLinks\t\t);\t\tif (entry-&gt;BaseDllName.Buffer &amp;&amp;\t\t\t_wcsicmp_impl(moduleName, entry-&gt;BaseDllName.Buffer) == 0) {\t\t\treturn entry-&gt;DllBase;\t\t}\t\tcurrent = current-&gt;Flink;\t}\treturn NULL;}int main() {\tTCHAR dllName[256];\t_tprintf(TEXT(\"Enter DLL name (example: kernel32.dll): \"));\tfgetws(dllName, _countof(dllName), stdin);\t// Remove trailing newline if it exists\tsize_t len = _tcslen(dllName);\tif (len &gt; 0 &amp;&amp; dllName[len - 1] == _T('\\n')) {\t\tdllName[len - 1] = _T('\\0');\t}\tPVOID baseAddress = GetModuleBase(dllName);\tif (baseAddress) {\t\t_tprintf(TEXT(\"%s base address: 0x%p\\n\"), dllName, baseAddress);\t\t// Verify using GetModuleHandle\t\tHMODULE hModule = GetModuleHandle(dllName);\t\t_tprintf(TEXT(\"GetModuleHandle result: 0x%p\\n\"), hModule);\t\tif ((PVOID)hModule == baseAddress) {\t\t\t_tprintf(TEXT(\"Verification successful!\\n\"));\t\t}\t\telse {\t\t\t_tprintf(TEXT(\"Warning: Address mismatch!\\n\"));\t\t}\t}\telse {\t\t_tprintf(TEXT(\"Failed to find %s\\n\"), dllName);\t}\treturn 0;}Conlcusion :Understanding how Windows internally tracks loaded modules using structures like _PEB, _PEB_LDR_DATA, and _LDR_DATA_TABLE_ENTRY opens the door to low-level techniques that bypass standard APIs. By manually traversing the loader‚Äôs linked lists, we can locate the base addresses of DLLs without relying on functions like GetModuleHandle, offering both stealth and flexibility.In this post, we built a minimal but powerful example that retrieves any loaded module‚Äôs base address directly through the PEB, showing how elegant and reliable direct memory inspection can be. Whether for malware analysis, red teaming, or building custom loaders, mastering these internal mechanisms is a valuable skill for any low-level Windows developer or security researcher.Key Considerations Offset Variations: Offsets may differ across Windows versions. Unicode Handling: Module names are case-insensitive Unicode strings. List Termination: Always check for circular list completion to avoid infinite loops. Memory Protection: Some fields in the structures may be read-protected.Why This Matters Deep Understanding: Learn how Windows manages modules. Shellcode Development: Essential for position-independent code. Anti-Analysis: Bypass API hooks and detection mechanisms. Debugging Skills: Better understand process memory layout.Common Pitfalls Structure Offsets: May change between Windows versions. Unicode Handling: Module names are case-insensitive Unicode. List Termination: Circular list - check for return to head. x86 vs x64: Different register usage (FS vs GS).Further Exploration Explore the Export Address Table (EAT). Study the PE file format in depth. Experiment with different Windows versions.References: Bypassing AV with direct syscalls and PEB walking - cocomelonc Windows Internals - Red Teaming‚Äôs Dojo by Mohamed Fakroud x64 WinAPI Shellcoding by print3m Windows Internals - PEB Overview by Faran-17 Understanding the Process Environment Block (PEB) for Malware Analysis" } ]
